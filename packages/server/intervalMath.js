"use strict";

const _ = require('underscore');

const MINUS_INFINITY = Number.NEGATIVE_INFINITY;
const INFINITY = Number.POSITIVE_INFINITY;

/**
 * Check whether an interval is empty. An interval consisting of a single point is not empty.
 */
function isEmpty(interval, comparator) {
  return comparator(interval.min, interval.max) > 0 ||
    (equals(interval.min, interval.max, comparator) && (!interval.maxInclusive || !interval.minInclusive));
}

/**
 * Compute the intersection of two intervals, using the specified comparator to compare values.
 */
function intervalIntersection(a, b, comparator) {
  var result = {
    min: max(a.min, b.min, comparator),
    max: min(a.max, b.max, comparator)
  };
  if(equals(result.min, a.min, comparator) && !a.minInclusive) {
    result.minInclusive = false;
  }
  else if(equals(result.min, b.min, comparator) && !b.minInclusive) {
    result.minInclusive = false;
  }
  else {
    result.minInclusive = true;
  }

  if(equals(result.max, a.max, comparator) && !a.maxInclusive) {
    result.maxInclusive = false;
  }
  else if(equals(result.max, b.max, comparator) && !b.maxInclusive) {
    result.maxInclusive = false;
  }
  else {
    result.maxInclusive = true;
  }
  if(isEmpty(result, comparator)) {
    return null;
  }
  return result;
}

/** Check if two intervals overlap. Two intervals may overlap by a single point.
 *
 */
function overlaps(a, b, comparator) {
  return intervalIntersection(a, b, comparator) !== null;
}

/**
 * returns the part of interval a that is to the left of b
 */
function left(a, b, comparator) {
  var result = {
    min: a.min,
    minInclusive: a.minInclusive,
    max: min(a.max, b.min, comparator)
  };
  if(equals(result.max, a.max, comparator) && !a.maxInclusive) {
    result.maxInclusive = false;
  }
  else if(equals(result.max, b.min, comparator) && b.minInclusive) {
    result.maxInclusive = false;
  }
  else {
    result.maxInclusive = true;
  }
  if(isEmpty(result, comparator)) {
    return null;
  }
  return result;
}

/**
 * return the part of interval a that is to the right of b
 */
function right(a, b, comparator) {
  const result = {
    min: max(a.min, b.max, comparator),
    max: a.max,
    maxInclusive: a.maxInclusive
  };
  if(equals(result.min, a.min, comparator) && !a.minInclusive) {
    result.minInclusive = false;
  }
  else if(equals(result.min,  b.max, comparator) && b.maxInclusive) {
    result.minInclusive = false;
  }
  else {
    result.minInclusive = true;
  }
  if(isEmpty(result, comparator)) {
    return null;
  }
  return result;
}

function max(a, b, comparator) {
  return comparator(a,b) <= 0 ? b : a;
}

function min(a, b, comparator) {
  return comparator(a,b) <= 0 ? a : b;
}

function equals(a, b, comparator) {
  return comparator(a,b) === 0;
}

/**
 * Check if two intervals are precicely adjacent to each other (and not overlapping)
 */
function isAdjacent(a, b, comparator) {
  return (equals(a.min, b.max, comparator) && (a.minInclusive !== b.maxInclusive)) ||
    (equals(a.max, b.min, comparator) && (a.maxInclusive !== b.minInclusive))
}


function intervalsEqual(a, b, comparator) {
  return equals(a.min, b.min, comparator) &&
    equals(a.max, b.max, comparator) &&
    a.minInclusive === b.minInclusive &&
    a.maxInclusive === b.maxInclusive;
}

/**
 * Merge two adjacent intervals into one. Assumes the intervals are adjacent.
 */
function mergeAdjacentIntervals(a, b, comparator) {
  if(equals(a.min, b.max, comparator)) {
    return {
      min: b.min,
      max: a.max,
      minInclusive: b.minInclusive,
      maxInclusive: a.maxInclusive
    };
  }
  else if(equals(a.max, b.min, comparator)) {
    return {
      min: a.min,
      max: b.max,
      minInclusive: a.minInclusive,
      maxInclusive: b.maxInclusive
    };
  }
  else {
    throw new Error('Intervals was not adjacent');
  }
}

/**
 * Given two intervals a and b:
 * return an array containing b, and zero, one or two additional intervals
 * containing the part of a that does not overlap with b.
 */
function applyIntervals(a, b, comparator) {
  const result = [b];
  const aLeft = left(a, b, comparator);
  const aRight = right(a, b, comparator);

  if(aLeft) {
    aLeft.ref = a.ref;
    result.push(aLeft);
  }
  if(aRight) {
    aRight.ref = a.ref;
    result.push(aRight);
  }
  return result;
}

/**
 * Sort an array of intervals by the lower bound, descending order.
 */
function sortByLeft(arr, comparator) {
  arr.sort((a, b) => {
    const c = comparator(a.min, b.min);
    if(c === 0) {
      if(a.minInclusive && !b.minInclusive) {
        return 1;
      }
      else if(!a.minInclusive && b.minInclusive) {
        return -1;
      }
      return 0;
    }
    return c;
  });
}

/**
 * Sort an array of intervals by the upper bound, ascending order.
 */
function sortByRight(arr, comparator) {
  arr.sort((a, b) => {
    const c = comparator(a.max, b.max);
    if(c === 0) {
      if(a.maxInclusive && !b.maxInclusive) {
        return -1;
      }
      else if(!a.maxInclusive && b.maxInclusive) {
        return 1;
      }
      return 0;
    }
    return -c;
  });
}

/**
 * Given a list of intervals, ensure that the intervals do not overlap by shrinking/splitting 
 * them appropriately.
 * The intervals should be given in prioritized order. If intervals overlap, the algorithm will
 * shrink/split the last one.
 */
function ensureNotOverlapping(intervals, comparator) {
  if(intervals.length <= 1) {
    return intervals;
  }
  const result = [intervals.shift()];
  for(const interval of intervals) {
    const pendingIntervals = [interval];
    while(pendingIntervals.length > 0) {
      const pendingInterval = pendingIntervals.pop();
      const overlappingInterval = result.find((interval) => overlaps(interval, pendingInterval, comparator));
      if(!overlappingInterval) {
        result.push(pendingInterval);
        continue;
      }
      result.splice(result.indexOf(overlappingInterval), 1);
      const newIntervals = applyIntervals(overlappingInterval, pendingInterval, comparator);
      for(const interval of newIntervals) {
        pendingIntervals.push(interval);
      }
    }
  }

  result.sort((a, b) => {
    return comparator(a.min, b.min);
  });
  const mergedResult = [result.shift()];
  for(let interval of result) {
    const last = mergedResult[mergedResult.length - 1];
    if(isAdjacent(last, interval, comparator) && _.isEqual(last.ref, interval.ref)) {
      mergedResult.pop();
      const mergedInterval = mergeAdjacentIntervals(last, interval, comparator);
      mergedInterval.ref = last.ref;
      mergedResult.push(mergedInterval);
    }
    else {
      mergedResult.push(interval);
    }
  }

  return mergedResult;
}

function extend(intervals, comparator) {
  intervals = ensureNotOverlapping(intervals, comparator);
  sortByRight(intervals, comparator);
  for(const interval of intervals) {
    interval.min = MINUS_INFINITY;
    interval.minInclusive = false;
  }
  intervals = ensureNotOverlapping(intervals, comparator);
  sortByLeft(intervals, comparator);
  for(const interval of intervals) {
    interval.max = INFINITY;
    interval.maxInclusive = false;
  }
  intervals = ensureNotOverlapping(intervals, comparator);
  return intervals;
}


module.exports = {
  valueMath: {
    min: min,
    max: max,
    equals: equals,
    numberComparator: function(a, b) {
      if(a === b) {
        return 0;
      }
      return a - b;
    }
  },
  equals: intervalsEqual,
  intersection: intervalIntersection,
  overlaps: overlaps,
  left: left,
  right: right,
  adjacent: isAdjacent,
  mergeAdjacent: mergeAdjacentIntervals,
  applyIntervals: applyIntervals,
  sortByLeft: sortByLeft,
  sortByRight: sortByRight,
  ensureNotOverlapping: ensureNotOverlapping,
  extend: extend
};
